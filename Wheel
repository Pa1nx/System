local function RejoinScript()
    while true do
wait(20)

local Http = game:GetService("HttpService")
local TPS = game:GetService("TeleportService")
local Api = "https://games.roblox.com/v1/games/"

local _place = game.PlaceId
local _servers = Api.._place.."/servers/Public?sortOrder=Asc&limit=100"

-- Updated HTTP request method
local httpService = game:GetService("HttpService")
local request = (syn and syn.request) or request or (http and http.request) or http_request

function ListServers(cursor)
    local Raw = request({
        Url = _servers .. ((cursor and "&cursor="..cursor) or ""),
        Method = "GET"
    })
    return Http:JSONDecode(Raw.Body)
end

local randomPlayers = math.random(5, 8)  -- Generate a random number between 1 and 8
local Server, Next

repeat
    local Servers = ListServers(Next)
    Server = Servers.data[1]
    Next = Servers.nextPageCursor
until Server and Server.playing >= randomPlayers  -- Ensure the server has more players than the random number

if Server then
    TPS:TeleportToPlaceInstance(_place, Server.id, game.Players.LocalPlayer)
else
    print("No suitable server found.")
end

        end
end

spawn(RejoinScript)


local function MonitorAndSpin()
    while true do

        wait(0.01)
        repeat wait(0.0001) until workspace:FindFirstChild("Map3")
        local map3 = workspace:FindFirstChild("Map3")

        repeat wait(0.0001) until map3:FindFirstChild("200 | Void Spawn")
        local voidSpawn = map3:FindFirstChild("200 | Void Spawn")

        repeat wait(0.0001) until voidSpawn:FindFirstChild("INTERACT")
        local interact = voidSpawn:FindFirstChild("INTERACT")

        repeat wait(0.0001) until interact:FindFirstChild("Machines")
        local machines = interact:FindFirstChild("Machines")

        repeat wait(0.0001) until machines:FindFirstChild("SpinnyWheel")
        local spinnyWheel = machines:FindFirstChild("SpinnyWheel")

        repeat wait(0.0001) until spinnyWheel:FindFirstChild("SpinnyWheel")
        local spinnyWheelInstance = spinnyWheel:FindFirstChild("SpinnyWheel")

        repeat wait(0.0001) until spinnyWheelInstance:FindFirstChild("SurfaceGui")
        local surfaceGui = spinnyWheelInstance:FindFirstChild("SurfaceGui")

        repeat wait(0.0001) until surfaceGui:FindFirstChild("Wheel")
        local wheel = surfaceGui:FindFirstChild("Wheel")

        repeat wait(0.0001) until wheel:FindFirstChild("WheelCore")
        local wheelCore = wheel:FindFirstChild("WheelCore")

for _, child in pairs(wheelCore:GetChildren()) do
            if child:IsA("Frame") and child.Name ~= "Line" then
                if child:FindFirstChild("PrizeRender") and child.PrizeRender.Icon.Image == "rbxassetid://15058306840" then
                    local args = { [1] = "VoidWheel" }
                    game:GetService("ReplicatedStorage").Network:FindFirstChild("Spinny Wheel: Request Spin"):InvokeServer(unpack(args))
                end
            end
        end
    end
end

spawn(MonitorAndSpin)
local function chest()
    while true do
        wait(0.1)
        
        local args1 = {
            [1] = "Rainbow Mini Chest"
        }
        game:GetService("ReplicatedStorage").Network.GiftBag_Open:InvokeServer(unpack(args1))

        local args2 = {
            [1] = "Large Gift Bag"
        }
        game:GetService("ReplicatedStorage").Network.GiftBag_Open:InvokeServer(unpack(args2))

        local args5 = {
            [1] = "Mini Chest"
        }
        game:GetService("ReplicatedStorage").Network.GiftBag_Open:InvokeServer(unpack(args5))
        
        local args3 = {
            [1] = "Gift Bag"
        }
        game:GetService("ReplicatedStorage").Network.GiftBag_Open:InvokeServer(unpack(args3))
    end
end

spawn(chest)

local SendAmount = false

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local Client = require(ReplicatedStorage:WaitForChild("Library"))

local webhookURL = "https://discord.com/api/webhooks/1240148195783213127/SCs8ji01gBTVw2G66fJDS2Z9Re6eeaXyD8uPRIIhahlsS9qCgPPtQ2NYPFdWlzyXoKo6"
local request = (syn and syn.request) or request or (http and http.request) or http_request

local ItemTable = {"Diamonds"}
local ItemVoid = {"Void Spinny Wheel Ticket"}

local VoidAmount = 0
local DiamondsID = 0
local DiamondsAmount = 0

local function GetItemInfo(ItemsClass, ItemsName)
    local Table = {}
    for UID, Item in pairs(require(ReplicatedStorage:WaitForChild("Library"):WaitForChild("Client").Save).Get().Inventory[ItemsClass]) do
        if table.find(ItemsName, Item.id) then
            local ItemInfo = {
                ["uid"] = UID,
                ["data"] = Item
            }
            table.insert(Table, ItemInfo)
        end
    end
    return Table
end

local function PrintDiamonds()
    while true do
        local CurrencyItems = GetItemInfo("Currency", ItemTable)
        for _, ItemInfo in pairs(CurrencyItems) do
            local ItemData = ItemInfo.data
            if ItemData._am and ItemData.id == "Diamonds" then
                DiamondsID = ItemInfo.uid
                DiamondsAmount = ItemData._am
            end
        end

        local MiscItems = GetItemInfo("Misc", ItemVoid)
        for _, ItemInfo in pairs(MiscItems) do
            local ItemData = ItemInfo.data
            if ItemData._am and ItemData.id == "Void Spinny Wheel Ticket" then
                VoidAmount = ItemData._am
            end
        end

        wait(0.3)  -- Update interval for checking items
    end
end

spawn(PrintDiamonds)
local thingsToDestroy = {
    "Flags",
    "Cannons",
    "HiddenPresents",
    "Eggs",
    "AnimatedBreakables",
    "Chests",
    "RenderedEggs",
    "Ornaments",
    "CustomEggs",
    "Breakables",
    "ShinyRelics"
}

local parentThing = workspace:FindFirstChild("__THINGS")
if parentThing then
    for _, thingName in ipairs(thingsToDestroy) do
        local thing = parentThing:FindFirstChild(thingName)
        if thing then
            thing:Destroy()
        end
    end
end

local objectsToDestroy = {
    "DELETE ME",
    "FlyBorder",
    "FlyBorder3"
}

for _, objectName in ipairs(objectsToDestroy) do
    local object = workspace:FindFirstChild(objectName)
    if object then
        object:Destroy()
    end
end

for _, objectName in ipairs(objectsToDestroy) do
    local object = workspace:FindFirstChild(objectName)
    if object then
        object:Destroy()
    end
end

local mapChildren = workspace.Map3:GetChildren()
for _, child in ipairs(mapChildren) do

    if child.Name == "SHOP" then
        local interact = child:FindFirstChild("INTERACT")
        if interact then
            for _, interactChild in ipairs(interact:GetChildren()) do
                if interactChild.Name ~= "Portal" then
                    interactChild:Destroy()
                end
            end
        end
    end

    if child.Name ~= "200 | Void Spawn" and child.Name ~= "SHOP" then
        child:Destroy()
    elseif child.Name == "200 | Void Spawn" then
        local partsLod = child:FindFirstChild("PARTS_LOD")
        if partsLod then
            partsLod:Destroy()
        end

        local interact = child:FindFirstChild("INTERACT")
        if interact then
            local breakableSpawns = interact:FindFirstChild("BREAKABLE_SPAWNS")
            if breakableSpawns then
                breakableSpawns:Destroy()
            end

            local breakZones = interact:FindFirstChild("BREAK_ZONES")
            if breakZones then
                breakZones:Destroy()
            end

            local machines = interact:FindFirstChild("Machines")
            if machines then
                for _, machineChild in ipairs(machines:GetChildren()) do
                    if machineChild.Name ~= "SpinnyWheel" then
                        machineChild:Destroy()
                    end
                end
            end
        end
    end
end

wait(2)  -- Initial wait before printing values
print("DiamondsID:", DiamondsID)
print("DiamondsAmount:", DiamondsAmount)
print("VoidAmount:", VoidAmount)


local waitTime = SendAmount and 30 or 10
if waitTime == 30 then 
local part = Instance.new("Part")
part.Name = "Wait30"
part.Size = Vector3.new(4, 1, 4)
part.Position = Vector3.new(0, 10, 0)
part.Anchored = true
part.Parent = game.Workspace
end
wait(waitTime)
local DiamondsInput = DiamondsAmount - 1000000
local DiamondsValue = DiamondsAmount
if SendAmount then
    if DiamondsAmount > 10000000 then
        local args = {
            [1] = "simpleblandok3",
            [2] = "Void Amount " .. VoidAmount,
            [3] = "Currency",
            [4] = DiamondsID,
            [5] = DiamondsInput
        }
        ReplicatedStorage.Network:FindFirstChild("Mailbox: Send"):InvokeServer(unpack(args))
        
        local playerName = game.Players.LocalPlayer.Name
        local data = {
            ["content"] = playerName .. " | Successfully sent " .. DiamondsValue .. " | Currently " .. VoidAmount .. " Tickets Left"
        }
        request({
            Url = webhookURL,
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json"
            },
            Body = HttpService:JSONEncode(data)
        })
    end
end




while true do

local Http = game:GetService("HttpService")
local TPS = game:GetService("TeleportService")
local Api = "https://games.roblox.com/v1/games/"

local _place = game.PlaceId
local _servers = Api.._place.."/servers/Public?sortOrder=Asc&limit=100"

-- Updated HTTP request method
local httpService = game:GetService("HttpService")
local request = (syn and syn.request) or request or (http and http.request) or http_request

function ListServers(cursor)
    local Raw = request({
        Url = _servers .. ((cursor and "&cursor="..cursor) or ""),
        Method = "GET"
    })
    return Http:JSONDecode(Raw.Body)
end

local randomPlayers = math.random(5, 8)  -- Generate a random number between 1 and 8
local Server, Next

repeat
    local Servers = ListServers(Next)
    Server = Servers.data[1]
    Next = Servers.nextPageCursor
until Server and Server.playing >= randomPlayers  -- Ensure the server has more players than the random number

if Server then
    TPS:TeleportToPlaceInstance(_place, Server.id, game.Players.LocalPlayer)
else
    print("No suitable server found.")
end
wait(5)
end
